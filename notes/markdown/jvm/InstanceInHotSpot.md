# HotSpot虚拟机对象探秘

- *探讨HotSpot虚拟机在Java堆中对象分配、布局、访问的全过程(针对普通对象，不是数组和Class对象)*

### 对象创建 
1. 虚拟机遇到new指令，先检查该指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经执行类加载过程
2. 类加载过程执行完后，为新生的对象分配内存，对象所需内存大小在类加载完成后便完全确定,分配方式有两种，取决于Java堆是否规整，是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
    1. 指针碰撞(Bump the Pointer)<-Java堆的内存是绝对规整的
    2. 空闲列表(Free List)<-Java堆内存并不是规整的
3. 分配内存动作的线程安全问题
    1. 同步分配内存的动作-虚拟机采用CAS配上失败重试的方式保证操作的原子性
    2. 每个线程在Java堆中预先分配一小块内存(即TLAB, 本地线程分配缓冲),内存分配的动作就按线程划分在不同的空间中进行，只有TLAB用完并分配新的TLAB时才需要同步锁定 -XX:+/-UseTLAB参数来设定是否使用TLAB
4. 内存分配完后再将分配到的内存空间都初始化为零值(不包括对象头)，保证对象的实例字段在不赋初始值就可以直接使用，可以访问到对应数据类型的零值
5. 对象头信息设置
6. new指令后会执行<init>初始化对象，因为所有的实例字段还都是零值

### 对象的内存布局
1. Header 对象头
    1. 对象自身的运行时数据(Mark Word) 会根据对象的状态复用自己的存储空间
    2. 类型指针 该对象的类的元数据的指针(类的元数据在方法区)，来确定对象是哪个类的实例
2. Instance Data
    - 对象真正存储的有效信息 各种类型字段的内容
3. Padding
    - 只是占位符的作用，并非必然
    - HotSpot VM自动内存管理系统要求对象的起始地址必须是8字节的整数倍，即对象大小必须是8字节的整数倍，对象头是，当实例数据不是时就填充来补全
    
### 对象的访问定位 (Java程序需要通过虚拟栈的栈帧的局部变量的reference数据来操作Java堆上的具体对象)
- 句柄 Java堆句柄池 句柄(对象实例数据指针和对象类型数据指针) reference存储句柄地址
- 直接指针 reference存储对象实例数据地址 对象实例数据会存储对象类型数据的指针 <- Sun HotSpot VM 好处是少了一次指针定位访问速度块



