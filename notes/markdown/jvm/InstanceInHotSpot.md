# HotSpot虚拟机对象探秘

- *探讨HotSpot虚拟机在Java堆中对象分配、布局、访问的全过程(针对普通对象，不是数组和Class对象)*

### 对象创建 
1. 虚拟机遇到new指令，先检查该指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经执行类加载过程
2. 类加载过程执行完后，为新生的对象分配内存(对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来)，对象所需内存大小在类加载完成后便完全确定,分配方式有两种，取决于Java堆是否规整，是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
    1. 指针碰撞(Bump the Pointer)<-Java堆的内存是绝对规整的
    2. 空闲列表(Free List)<-Java堆内存并不是规整的
3. 分配内存动作的线程安全问题 (仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况)
    1. 同步分配内存的动作-虚拟机采用CAS配上失败重试的方式保证操作的原子性
    2. 每个线程在Java堆中预先分配一小块内存(即TLAB, 线程本地分配缓冲),内存分配的动作就按线程划分在不同的空间中进行，只有TLAB用完并分配新的TLAB时才需要同步锁定 -XX:+/-UseTLAB参数来设定是否使用TLAB
    3. (-XX:+UseTLAB
        Enables the use of thread-local allocation blocks (TLABs) in the young generation space. This option is enabled by default. To disable the use of TLABs, specify -XX:-UseTLAB.)
4. 内存分配完后再将分配到的内存空间都初始化为零值(不包括对象头)，保证对象的实例字段在不赋初始值就可以直接使用，可以访问到对应数据类型的零值
5. 对象头信息设置
6. new指令后会执行实例构造器<init>初始化对象，因为所有的实例字段还都是零值。实际情况是：构造器只是负责对java对象实例变量执行初始化（也就是赋初始值），在执行构造器代码之前，该对象所占的内存已经被分配下来，这些内存里值都默认是零值。类似类构造器＜clinit＞
- <init>
    - Java 编译器在编译每个类时都会为该类至少生成一个实例初始化方法--即 "<init>()" 方法。此方法与源代码中的每个构造方法相对应，如果类没有明确地声明任何构造方法，编译器则为该类生成一个默认的无参构造方法，这个默认的构造器仅仅调用父类的无参构造器，与此同时也会生成一个与默认构造方法对应的 "<init>()" 方法
    - 通常来说，<init>() 方法内包括的代码内容大概为：调用另一个 <init>() 方法；对实例变量初始化；与其对应的构造方法内的代码
    - 如果构造方法不是通过调用自身类的其它构造方法开始，并且该对象不是 Object 对象，那 <init>() 法内则包括的内容为：一个对父类 <init>() 方法的调用；对实例变量初始化方法的字节码；最后是对应构造子的方法体字节码。
### 对象的内存布局
1. Header 对象头
    1. 对象自身的运行时数据(Mark Word) 会根据对象的状态复用自己的存储空间
    2. 类型指针 该对象的类的元数据的指针(类的元数据在方法区)，来确定对象是哪个类的实例
2. Instance Data
    - 对象真正存储的有效信息 各种类型字段的内容
3. Padding
    - 只是占位符的作用，并非必然
    - HotSpot VM自动内存管理系统要求对象的起始地址必须是8字节的整数倍，即对象大小必须是8字节的整数倍，对象头是，当实例数据不是时就填充来补全
    
### 对象的访问定位 (Java程序需要通过虚拟栈的栈帧的局部变量的reference数据来操作Java堆上的具体对象)
- 句柄 Java堆句柄池 句柄(对象实例数据指针和对象类型数据指针) reference存储句柄地址
- 直接指针 reference存储对象实例数据地址 对象实例数据会存储对象类型数据的指针 <- Sun HotSpot VM 好处是少了一次指针定位访问速度块



