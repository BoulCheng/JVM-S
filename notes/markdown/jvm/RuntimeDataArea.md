# 运行时数据区域
- 程序计数器
    - 当前线程所执行的字节码行号指示器
    - 每个线程有一个独立的程序计数器
    - 线程私有
    - 没有任何OutOfMemoryError
    
- 虚拟机栈(生命周期与线程相同)
    - 每个线程有一个私有的栈，随着线程的创建而创建,每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息
    - Java方法执行的内存模型(区别native方法)
    - 线程私有
    - 方法的调用到完成，对应一个栈帧在虚拟机栈中入栈到出栈
    - 栈帧中局部变量表所需内存空间在编译期间完成分配，包括基本数据类型和对象引用等
    - 线程请求的栈深度大于虚拟机允许的深度，抛出StackOverflowError
    - 虚拟机栈动态扩展无法申请足够的内存，抛出OutOfMemoryError
```
1.定义
     栈帧（stack frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。
     每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
     对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作
2.组成
 （1）局部变量表
      局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的
      最大局部变量表的容量。
      局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。
      reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。
      returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。
      虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。
      Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。
  系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。
 （2）操作数栈
      Java虚拟机的解释执行引擎被称为"基于栈的执行引擎"，其中所指的栈就是指－操作数栈。
      操作数栈也常被称为操作栈。
     和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作—压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。
      虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。
      虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，看看下面的示例，它演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：

begin  
iload_0    // push the int in local variable 0 onto the stack  
iload_1    // push the int in local variable 1 onto the stack  
iadd       // pop two ints, add them, push result  
istore_2   // pop int, store into local variable 2  
end  

在这个字节码序列里，前两个指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中，其后iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈。第四条指令istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。下图详细表述了这个过程中局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示。
```

- 本地方法栈
    - 为虚拟机使用到的native方法服务，而虚拟机栈为虚拟机执行Java方法即字节码服务
    - HotSpot虚拟机本地方法栈和虚拟机栈合二为一
    - 会抛出StackOverflowError、OutOfMemoryError

- Java堆
    - 存放对象实例和数组
    - 线程共享
    - 虚拟机启动时创建
    - 垃圾收集器管理的主要区域
    - Java堆划分 
        - 内存回收角度 (垃圾收集器采用分代收集算法)
            - 新生代和老年代(更细: Eden空间、From Survivor空间、To Survivor空间等)
        - 内存分配角度
            - Java可能划分出多个线程私有的分配缓存区(TLAB)
    - Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，如磁盘空间
    - Java堆可扩张实现的调整 -Xmx -Xms 
    - OutOfMemoryError
    
- 方法区【虚拟机规范】(HotSpot虚拟机中的永久代 PermGen) **JDK8已移除永久代-The proposed implementation will allocate class meta-data(可理解为类对象【区别实例对象】 Class对象) in native memory and move interned Strings and class statics to the Java heap.**
    - 方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等
    - 存放被虚拟机加载的类信息、常量、静态变量等
    - 线程共享
    - JVMS把方法区描述为堆的一个逻辑部分，但取名为Non-Heap，为了和Java堆区分开
    - HopSpot虚拟机使用永久代来实现方法区是为了垃圾收集器可以像管理Java堆一个管理方法区，但更容易内存溢出(永久代有 -XX:MaxPermSize 上线)，其他虚拟机没有永久代的概念，
    - JDK1.7的HotSpot中已经把字符串常量池从永久代中移除
    - 回收目标主要是常量池的回收和对类型的卸载
    - 可以处于物理上不连续的内存空间，可固定大小实现也可扩展实现
    - OutOfMemoryError
    - 虚拟机规范中方法区的具体实现
        - PermGen（永久代）: “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。
        - (JDK8永久代(永久代是堆的一部分)已经被移除)元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
        - JDK 8 中永久代向元空间的转换:
            - 字符串存在永久代中，容易出现性能问题和内存溢出
            - 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
            - 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
            
- *运行时常量池(方法区的一部分)*
    - 存放(类加载后)class文件中的常量池(编译器生成的字面量和符号引用)
    - 运行时常量池相对于Class文件常量池的另一个重要特性是具备动态性，因为并非只有编译期可以产生常量，运行期也可能产生新的常量放入方法区运行时常量池(如String.intern())
    - OutOfMemoryError
    
- *直接内存DirectMemory 不是虚拟机运行时数据区*
   - 不是虚拟机运行时数据区 也不是JVMS中定义的内存区域
   - NIO类可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了Java堆和Native堆来回复复制数据
   - 不受Java堆大小限制
   - -XX:MaxDirectMemorySize 未设置则默认为最大堆内存大小，即与 -Xmx 相同
   - OutOfMemoryError
